rules_version = '2';

/**
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model. All user-generated data is
 * stored within a dedicated data tree under `/users/{userId}`, ensuring that users
 * can only access and manage their own information. This path-based security
 * model is simple, performant, and secure by default.
 *
 * Data Structure:
 * The data is organized hierarchically. A top-level `/users` collection contains
 * individual user documents, identified by the user's Authentication UID. Each
 * user document (`/users/{userId}`) has multiple subcollections for different
 * types of data, such as `linkedin_posts`, `resume_analyses`, `skill_gap_roadmaps`,
 * and `mock_interviews`.
 *
 * Key Security Decisions:
 * - Strict Ownership: All operations (read, write, delete) are restricted to the
 *   authenticated owner of the data. There are no public or shared collections.
 * - No User Enumeration: Listing documents in the top-level `/users` and `/posts` collections is
 *   explicitly disallowed to protect user privacy.
 * - Self-Creation of Profiles: A user is permitted to create their own user
 *   profile document upon first sign-in or sign-up, which is a common requirement
 *   that resolves `auth/operation-not-allowed` errors.
 * - Relational Integrity: On creation, rules validate that the `userId` (or `id`
 *   for the user profile) inside a document matches the `userId` in the path. On
 *   update, this field is enforced as immutable to prevent re-linking data.
 *
 * Denormalization for Authorization:
 * This ruleset's design is inherently efficient. By nesting all data under a
 * path containing the user's ID (`/users/{userId}` or `/posts/{userId}`), authorization decisions are
 * made directly from the path, eliminating the need for slow and costly `get()`
 * calls to other documents.
 *
 * Structural Segregation:
 * Each distinct type of user data (e.g., LinkedIn posts, resume analyses) is
 * stored in its own dedicated subcollection. This segregation simplifies rules,
 * optimizes queries, and provides a clean data model.
 */
service cloud.firestore {
  match /databases/{database}/documents {

    // ---------------- HELPER FUNCTIONS ----------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the authenticated user's UID matches the provided userId.
     * This is the core function for enforcing ownership.
     * @param userId The user ID to check against the request's auth UID.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks for ownership on an existing document. Used for update/delete.
     * Prevents operations on documents that do not exist.
     * @param userId The user ID to check against the request's auth UID.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * Validates that a new UserProfile document has an 'id' field that
     * matches the document's ID (the user's UID).
     * @param userId The user's UID from the path.
     */
    function isCreatingValidUserProfile(userId) {
      return request.resource.data.id == userId;
    }

    /**
     * Validates that the 'id' field of a UserProfile is immutable on update.
     * @param userId The user's UID from the path (unused but kept for consistency).
     */
    function isUpdatingValidUserProfile() {
      return request.resource.data.id == resource.data.id;
    }

    /**
     * Validates that a new document in a user subcollection has a 'userId'
     * field that correctly links back to the parent user.
     * @param userId The parent user's UID from the path.
     */
    function isCreatingValidSubcollectionDoc(userId) {
      return request.resource.data.userId == userId;
    }

    /**
     * Validates that the 'userId' field of a subcollection document is
     * immutable on update, preventing it from being reassigned.
     * @param userId The parent user's UID from the path (unused but kept for consistency).
     */
    function isUpdatingValidSubcollectionDoc() {
      return request.resource.data.userId == resource.data.userId;
    }


    // ---------------- COLLECTION RULES ----------------

    /**
     * @description Rules for UserProfile documents. Users can manage their own profile.
     * @path /users/{userId}
     * @allow (create) An authenticated user with UID 'user_abc' creating their own profile at `/users/user_abc`.
     * @deny (list) Any user trying to list all documents in the `/users` collection.
     * @deny (get) User 'user_xyz' trying to read `/users/user_abc`.
     * @principle Restricts access to a user's own data tree and allows self-creation of the root user document.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow create: if isOwner(userId) && isCreatingValidUserProfile(userId);
      allow update: if isExistingOwner(userId) && isUpdatingValidUserProfile();
      allow delete: if isExistingOwner(userId);
      allow list: if false; // CRITICAL: Prevents user enumeration.
    }

    /**
     * @description Top-level collection for posts. Only allows access to subcollections.
     * @path /posts/{userId}
     */
    match /posts/{userId} {
        allow read, write: if false; // Disallow direct access to user-level post documents
    }

    /**
     * @description Rules for user-generated LinkedIn posts.
     * @path /posts/{userId}/linkedin_posts/{linkedInPostId}
     * @allow (create) User 'user_abc' creating a new post at `/posts/user_abc/linkedin_posts/post_123`.
     * @deny (update) User 'user_xyz' trying to update a post at `/posts/user_abc/linkedin_posts/post_123`.
     * @principle Enforces document ownership within a user-specific subcollection.
     */
    match /posts/{userId}/linkedin_posts/{linkedInPostId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId); // Simplified for client-side writes
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for user-generated resume analyses.
     * @path /users/{userId}/resume_analyses/{resumeAnalysisId}
     * @allow (list) User 'user_abc' listing their own resume analyses at `/users/user_abc/resume_analyses`.
     * @deny (get) An unauthenticated user trying to read any resume analysis.
     * @principle Enforces document ownership within a user-specific subcollection.
     */
    match /users/{userId}/resume_analyses/{resumeAnalysisId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && isCreatingValidSubcollectionDoc(userId);
      allow update: if isExistingOwner(userId) && isUpdatingValidSubcollectionDoc();
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for user-generated skill gap roadmaps.
     * @path /users/{userId}/skill_gap_roadmaps/{skillGapRoadmapId}
     * @allow (delete) User 'user_abc' deleting their own roadmap at `/users/user_abc/skill_gap_roadmaps/roadmap_123`.
     * @deny (create) User 'user_abc' creating a roadmap where the document's `userId` field is set to 'user_xyz'.
     * @principle Validates relational integrity by ensuring the document data links back to the parent path.
     */
    match /users/{userId}/skill_gap_roadmaps/{skillGapRoadmapId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && isCreatingValidSubcollectionDoc(userId);
      allow update: if isExistingOwner(userId) && isUpdatingValidSubcollectionDoc();
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for user's mock interview data.
     * @path /users/{userId}/mock_interviews/{mockInterviewId}
     * @allow (get) User 'user_abc' reading their own interview at `/users/user_abc/mock_interviews/interview_123`.
     * @deny (delete) User 'user_xyz' trying to delete an interview at `/users/user_abc/mock_interviews/interview_123`.
     * @principle Enforces document ownership within a user-specific subcollection.
     */
    match /users/{userId}/mock_interviews/{mockInterviewId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && isCreatingValidSubcollectionDoc(userId);
      allow update: if isExistingOwner(userId) && isUpdatingValidSubcollectionDoc();
      allow delete: if isExistingOwner(userId);
    }
  }
}